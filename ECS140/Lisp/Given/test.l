; LISP test file
;
;;;;;;;;;  reminder to staff: do NOT edit this file by hand.
;                             it was generated automatically.
;

; for a specific part, to test everything interactively:
;    -- enter clisp:
;          clisp -q -i ../init.lsp
;       note: ../init.lsp is in Given
;             it includes
;                (setq *print-case* :downcase)
;             Output.correct was generated using that.
;    -- use one of the ty functions to test everything
;       for example, in part 1, give the command:
;          (ty1)
;    -- exit clisp
;          (quit)   or   ^D
;    -- compare your output vs. correct output:
;          diff Output.correct Output.your
;       or
;          tkdiff Output.correct Output.your
;       files should be identical.
;
; NB:  clisp output formatting takes into account the number of columns
; in your window.  The Output.correct file was generated
; for 80 column output.  Your output may differ for different sized windows.
; It's okay if your output is the same except for whitespace formatting
; (but easier, so you can use diff, if you run in an 80 column window).
;
; you might find some of the other functions below helpful in your testing
; e.g., to test all of part2 (and all of part1)
;       w/o writing to Output.your, use
;          (test-part2)
; e.g., to test only all of part2 but none of part1
;        w/o writing to Output.your, use
;          (test-only-part2)

(defun testOneSaveOutput (testPartFunction)
	(saveOutputBegin)
	(testOne testPartFunction)
	(saveOutputEnd)
)
(defun testOne (testPartFunction)
	(format t "~%~10TBEGIN TESTING~2%")
	(funcall testPartFunction)
        (format t "~%~10TDONE TESTING~2%")
	t
)

; delete-file is needed because some clisps (e.g., the one on Linux PC)
; append rather than truncate when dribbling to an existing file.
(defun saveOutputBegin ()
        (delete-file "Output.your")
	(dribbleNoTimeStamp "Output.your")
)
(defun saveOutputEnd ()
	(dribbleNoTimeStamp)
)


;;;; modified from clisp-2.49/src/dribble.lisp
;;;;
;;;; as name suggests, doesn't output timestamp
;;;; so that diff doesn't complain about different timestamps.
;;;;
;;;; since original dribble is in SYSTEM and this dribble isn't,
;;;; needed to add a few SYSTEM:: for some functions.
;;;;    (I might have missed some.)
;;;;    (would need on date-string if used that again.)

;;;; Dribble

(defun dribbleNoTimeStamp-toggle (stream &optional file)
  (multiple-value-bind (source target) (dribble-stream stream)
    (if source
      (if file                  ; already dribbling
        (warn (SYSTEM::TEXT "Already dribbling ~S to ~S") source target)
        (progn
          ;;(format target (TEXT "~&;; Dribble of ~S finished on ~A.~%")
          ;;        source (date-string))
          (format target (SYSTEM::TEXT "~&;; DribbleNoTimeStamp of ~S finished.~%")
                  source)
          (values source target)))
      (if file                    ; not dribbling
        (let ((target
               (if (and (streamp file)
                        (open-stream-p file) (output-stream-p file))
                 file
                 (open file :direction :output
                            :external-format (stream-external-format stream)
                            :if-exists :append
                            :if-does-not-exist :create))))
          ;;(format target (SYSTEM::TEXT ";; DribbleNoTimeStamp of ~S started on ~A.~%")
          ;;        stream (date-string))
          (format target (SYSTEM::TEXT ";; DribbleNoTimeStamp of ~S started.~%")
                  stream)
          (values (make-dribble-stream stream target) target))
        (warn (SYSTEM::TEXT "Currently not dribbling from ~S.") stream)))))

(defun dribbleNoTimeStamp (&optional file)
  (multiple-value-bind (source target) (dribbleNoTimeStamp-toggle *terminal-io* file)
    (when (streamp source)         ; no warning
      (unless file (close target)) ; dribble off
      (setq *terminal-io* source))
    target))
; part tests (each tests all previous parts and all in this part)
; output saved to a file
(defun ty1 () (testOneSaveOutput  #'test-part1))
(defun ty2 () (testOneSaveOutput  #'test-part2))
(defun ty3 () (testOneSaveOutput  #'test-part3))
(defun ty4 () (testOneSaveOutput  #'test-part4))
(defun ty5 () (testOneSaveOutput  #'test-part5))
(defun ty6 () (testOneSaveOutput  #'test-part6))
(defun ty7 () (testOneSaveOutput  #'test-part7))
(defun ty8 () (testOneSaveOutput  #'test-part8))
(defun ty9 () (testOneSaveOutput  #'test-part9))
; part tests (each tests all previous parts and all in this part)
(defun test-part1 () (test-only-part1))
(defun test-part2 ()
	(test-part1)
	(test-only-part2)
)
(defun test-part3 ()
	(test-part2)
	(test-only-part3)
)
(defun test-part4 ()
	(test-part3)
	(test-only-part4)
)
(defun test-part5 ()
	(test-part4)
	(test-only-part5)
)
(defun test-part6 ()
	(test-part5)
	(test-only-part6)
)
(defun test-part7 ()
	(test-part6)
	(test-only-part7)
)
(defun test-part8 ()
	(test-part7)
	(test-only-part8)
)
(defun test-part9 ()
	(test-part8)
	(test-only-part9)
)
; some shorthands, so that you can just type, e.g., (tp1)
(defun tp1 () (test-part1))
(defun tp2 () (test-part2))
(defun tp3 () (test-part3))
(defun tp4 () (test-part4))
(defun tp5 () (test-part5))
(defun tp6 () (test-part6))
(defun tp7 () (test-part7))
(defun tp8 () (test-part8))
(defun tp9 () (test-part9))
(defun top1 () (test-only-part1))
(defun top2 () (test-only-part2))
(defun top3 () (test-only-part3))
(defun top4 () (test-only-part4))
(defun top5 () (test-only-part5))
(defun top6 () (test-only-part6))
(defun top7 () (test-only-part7))
(defun top8 () (test-only-part8))
(defun top9 () (test-only-part9))
; part specific tests
(defun test-only-part1 ()
	(test-isLL2)
	(test-isLL2a)
)
(defun test-only-part2 ()
	(test-isLpairs)
	(test-isLpairs1st)
)
(defun test-only-part3 () (test-distribute))
(defun test-only-part4 ()
	(test-undistribute)
	(test-distribute+undistribute)
)
(defun test-only-part5 () (test-my-every))
(defun test-only-part6 () (test-lenLL))
(defun test-only-part7 () (test-simplify-not))
(defun test-only-part8 () (test-simplify))
(defun test-only-part9 () (test-check))
; some abbreviations, so that you can just type, e.g., (ti)
(defun ti () (test-isLL2))
(defun ta () (test-isLL2a))
(defun tp () (test-isLpairs))
(defun t1 () (test-isLpairs1st))
(defun td () (test-distribute))
(defun tu () (test-undistribute))
(defun tdu () (test-distribute+undistribute))
(defun te () (test-my-every))
(defun tl () (test-lenLL))
(defun tn () (test-simplify-not))
(defun ts () (test-simplify))
(defun tc () (test-check))
; test the isLL2 functions
(defun test-isLL2 ()
        (format t "~%~20TTEST-isLL2~2%")
	(test-an-is 'isll2)
        t
)
; test the isLL2a functions
(defun test-isLL2a ()
        (format t "~%~20TTEST-isLL2a~2%")
	(test-an-is 'isll2a)
        t
)

; test all the isLpairs functions
(defun test-isLpairs ()
        (format t "~%~20TTEST-isLpairs~2%")
        (test-isLpairs-recursive)
        (test-isLpairs-iterative)
        (test-isLpairs-every)
        t
)
(defun test-isLpairs-recursive ()
        (test-an-is 'isLpairs-recursive)
        t
)
(defun test-isLpairs-iterative ()
        (test-an-is 'isLpairs-iterative)
        t
)
(defun test-isLpairs-every ()
        (test-an-is 'isLpairs-every)
        t
)
; test all the isLpairs1st1st functions
(defun test-isLpairs1st ()
        (format t "~%~20TTEST-isLpairs1st~2%")
        (test-isLpairs1st-recursive)
        (test-isLpairs1st-iterative)
        (test-isLpairs1st-every)
        t
)
(defun test-isLpairs1st-recursive ()
        (test-an-is 'isLpairs1st-recursive)
        t
)
(defun test-isLpairs1st-iterative ()
        (test-an-is 'isLpairs1st-iterative)
        t
)
(defun test-isLpairs1st-every ()
        (test-an-is 'isLpairs1st-every)
        t
)

; tests the is function is-fun.
; prints out is-fun instead of actual name,
; e.g., (is-fun nil) instead of (isLL2-recursive nil)
;
(defun test-an-is (fun)
        (format t "~%~30TTEST-AN-IS on:  ~A~2%" fun)
        (defun is-fun (q) (funcall fun q))
        (tester '(is-fun 88) )
        (tester '(is-fun nil) )
        (tester '(is-fun '(1)) )
        (tester '(is-fun '(1 2)) )
        (tester '(is-fun '(1 (a))) )
        (tester '(is-fun '(1 (a b c))) )
        (tester '(is-fun '(1 (a b c d e))) )
        (tester '(is-fun '((1 2))) )
        (tester '(is-fun '((1 2) (3 4))) )
        (tester '(is-fun '((1 2) (a))) )
        (tester '(is-fun '((1 2) (a c e))) )
        (tester '(is-fun '((1 2) (3 4) 5)) )
        (tester '(is-fun '((1 2) 3 (4) 5)) )
        (tester '(is-fun '((1 2) (3 4) (5 6))) )
        (tester '(is-fun '((1 2) (1 4) (1 6))) )
        (tester '(is-fun '((1 2) (3 4) (1 6))) )
        (tester '(is-fun '(((1) 2) ((1) 4) ((1) 6))) )
        (tester '(is-fun '((() 2) (() 4) (() 6))) )
        (tester '(is-fun '((a 2) (b 4) (a 6))) )
        (tester '(is-fun '((a 2) (a 4) (a 6))) )
        (tester '(is-fun '((((a 2 3 4 5))) (a 4) (a 6))) )
        (tester '(is-fun '(((a (2) (3) 4 5)) (a 4) (a 6))) )
        (tester '(is-fun '(((a (2) (3) 4 5)) (a 1 2 3 8 7 4) (a 6))) )
        (tester '(is-fun '(((a (2) (3) 4 5)) (a 1 2 3 8 7 4) ((a b c d e f g 6)))) )
        t
)

; test all the distribute functions
(defun test-distribute ()
        (format t "~%~20TTEST-distribute~2%")
        (test-distribute-recursive)
        (test-distribute-iterative)
        (test-distribute-mapcar)
        t
)
(defun test-distribute-recursive ()
        (test-an-is 'distribute-recursive)
        t
)
(defun test-distribute-iterative ()
        (test-an-is 'distribute-iterative)
        t
)
(defun test-distribute-mapcar ()
        (test-an-is 'distribute-mapcar)
        t
)

; test all the undistribute functions
(defun test-undistribute ()
        (format t "~%~20TTEST-undistribute~2%")
        (test-undistribute-recursive)
        (test-undistribute-iterative)
        (test-undistribute-mapcar)
        t
)
(defun test-undistribute-recursive ()
        (test-an-is 'undistribute-recursive)
        t
)
(defun test-undistribute-iterative ()
        (test-an-is 'undistribute-iterative)
        t
)
(defun test-undistribute-mapcar ()
        (test-an-is 'undistribute-mapcar)
        t
)

(defun test-distribute+undistribute ()
        (format t "~%~20TTEST-distribute+undistribute~2%")
        (test-distribute+undistribute-recursive)
        (test-distribute+undistribute-iterative)
        (test-distribute+undistribute-mapcar)
        t
)
(defun test-distribute+undistribute-recursive ()
        (test-a-distribute+undistribute
	 'distribute-recursive 'undistribute-recursive)
        t
)
(defun test-distribute+undistribute-iterative ()
        (test-a-distribute+undistribute
	 'distribute-iterative 'undistribute-iterative)
        t
)
(defun test-distribute+undistribute-mapcar ()
        (test-a-distribute+undistribute
	 'distribute-mapcar 'undistribute-mapcar)
        t
)

(defun test-a-distribute+undistribute (dfun ufun)
        (format t "~%~30TTEST-A-DISTRIBUTE+UNDISTRIBUTE on:  ~A  ~A~2%"
		   dfun ufun)
        (defun distribute-fun (q) (funcall dfun q))
        (defun undistribute-fun (q) (funcall ufun q))
        (tester '(undistribute-fun (distribute-fun '(1 (a b)) )) )
        (tester '(undistribute-fun (distribute-fun '(2 (a b (c) (d e))) )) )
        (tester '(distribute-fun (undistribute-fun '((1 a) (1 b)) ) ) )
        (tester '(distribute-fun (undistribute-fun '((2 a) (2 (b c)) (2 e) (2 d)))))
	t
)

(defun test-lenLL ()
        (format t "~%~20TTEST-MY-lenLL~2%")
        (test-an-is 'lenLL)
        t
)

(defun test-my-every ()
        (format t "~%~20TTEST-MY-EVERY~2%")
        (tester '(my-every #'listp '()))
        (tester '(my-every #'listp '(1)))
        (tester '(my-every #'listp '(1 2)))
        (tester '(my-every #'listp '(1 2 3)))
        (tester '(my-every #'integerp '()))
        (tester '(my-every #'integerp '(1)))
        (tester '(my-every #'integerp '(1 2)))
        (tester '(my-every #'integerp '(1 2 3)))
        (tester '(my-every #'integerp '(1 a 2)))
        (tester '(my-every #'integerp '(a 1 2)))
        (tester '(my-every #'integerp '(1 2 a)))
        (tester '(my-every #'(lambda (a) (> a 4)) '(5 6 9)))
        (tester '(my-every #'(lambda (a) (> a 4)) '(5 6 0 9)))
        t
)

(defun test-simplify-not ()
	(format t "~%~20TTEST-SIMPLIFY-NOT~2%")
	(test-a-simplify 'simplify-not)
	t
)
(defun test-simplify ()
	(format t "~%~20TTEST-SIMPLIFY~2%")
	(test-a-simplify 'simplify)
	t
)
(defun test-check ()
        (format t "~%~20TTEST-CHECK~2%")
        (test-a-simplify 'check)
        t
)


; test expressions and variable values for check chosen
; so as not to exhibit difference in HW simplification and LISP.
; e.g., on (or a t), HW => t, LISP => a's value.
(defun test-a-simplify (fun)
        (format t "~%~30TTEST-A-SIMPLIFY on:  ~A~2%" fun)
        (defun simplify-fun (y) (funcall fun y))

	(tester '(simplify-fun 44))
	(tester '(simplify-fun t))
	(tester '(simplify-fun nil))

	(tester '(simplify-fun '(not t)))
	(tester '(simplify-fun '(not nil)))
	(tester '(simplify-fun '(not (not t))))
	(tester '(simplify-fun '(not (not nil))))
	(tester '(simplify-fun '(not (not (not t)))))
	(tester '(simplify-fun '(not (not (not nil)))))
	(tester '(simplify-fun '(list (not (not nil)))))
	(tester '(simplify-fun '(not (list (not nil)))))
	(tester '(simplify-fun '(not (not (list nil)))))
	(tester '(simplify-fun '(equal (not (not (list nil))) (not (not (list nil))))))
	(tester '(simplify-fun '(equal (not (not (list nil))) (not (list (not nil))))))
	(tester '(simplify-fun '(equal (not (list (not nil))) (not (list (not nil))))))
	(tester '(simplify-fun '(equal (not (list (not nil))) (not (not (list nil))))))

	(tester '(simplify-fun '(and)))
	(tester '(simplify-fun '(or)))

	(tester '(simplify-fun '(and t)))
	(tester '(simplify-fun '(and t t)))
	(tester '(simplify-fun '(and t t t)))
	(tester '(simplify-fun '(or t)))
	(tester '(simplify-fun '(or t)))
	(tester '(simplify-fun '(or t t t)))
	(tester '(simplify-fun '(and nil)))
	(tester '(simplify-fun '(and nil nil)))
	(tester '(simplify-fun '(and nil nil nil)))
	(tester '(simplify-fun '(or nil)))
	(tester '(simplify-fun '(or nil nil)))
	(tester '(simplify-fun '(or nil nil nil)))

	(tester '(simplify-fun '(and t nil)))
	(tester '(simplify-fun '(and nil t nil)))
	(tester '(simplify-fun '(and nil t nil t nil)))
	(tester '(simplify-fun '(or t nil)))
	(tester '(simplify-fun '(or nil t nil)))
	(tester '(simplify-fun '(or nil t nil t nil)))

	(tester '(simplify-fun '(and a)))
	(tester '(simplify-fun '(or a)))

	(tester '(simplify-fun '(and t a)))
	(tester '(simplify-fun '(and a t)))
	(tester '(simplify-fun '(and a t b)))
	(tester '(simplify-fun '(and a nil t b t c)))
	(tester '(simplify-fun '(and a t b t c)))
	(tester '(simplify-fun '(or nil a)))
	(tester '(simplify-fun '(or a nil)))
	(tester '(simplify-fun '(or t a nil)))
	(tester '(simplify-fun '(or nil a t nil)))
	(tester '(simplify-fun '(or nil t nil a t nil b)))
	(tester '(simplify-fun '(or nil nil a t nil b)))

	(tester '(simplify-fun '(and and a nil t b t c)))
	(tester '(simplify-fun '(and and a t b t c)))
	(tester '(simplify-fun '(list and a nil t b t c)))
	(tester '(simplify-fun '(or or nil nil a t nil b)))
	(tester '(simplify-fun '(or or nil nil a nil b)))
	(tester '(simplify-fun '(list or nil nil a t nil b)))

	(tester '(simplify-fun '(and (and t) (and t t t) t)))
	(tester '(simplify-fun '(and (and t) (and t a t) t)))
	(tester '(simplify-fun '(and (and t) (and t nil a t) t)))
	(tester '(simplify-fun '(and (and (or)) (and t nil a t) t)))
	(tester '(simplify-fun '(and (and (or t)) (and t t) t)))
	(tester '(simplify-fun '(list (and (and (or t)) (and t t) t))))
	(tester '(simplify-fun '(list (and (and (atom (or t))) (and t t) t))))
	(tester '(simplify-fun '(list (and (and b (atom (or t))) (and t t) t))))

	(tester '(simplify-fun '(or (or t) nil)))
	(tester '(simplify-fun '(or (or nil) (and t a t) nil)))
	(tester '(simplify-fun '(or (or t) (and t nil a t) nil)))

	(tester '(simplify-fun '(list (and (and (not (not b)) (atom (not (or nil)))) (and t t) t))))
	(tester '(simplify-fun '(list (or (and (not (not b)) (atom (not (and nil)))) (or t t) 3))))
	(tester '(simplify-fun '(list (or (and (not (not b)) (atom (not (and nil)))) (or 1 2) 3))))

	t
)

; low-level testing routine
(defun tester (x)
        (format t "testing:  ~A~%" x)
        ; split into 2 so print value even if eval fails.
        (format t "value:    ")
        (format t "~A~2%" (eval x))
        t
)
